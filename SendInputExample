using System;
using System.Threading;
using System.Runtime.InteropServices;

public class SendInputExample
{

    [StructLayout(LayoutKind.Sequential)]
    public struct HardwareInput
    {
        public uint uMsg;
        public ushort wParamL;
        public ushort wParamH;
    };
    [StructLayout(LayoutKind.Sequential)]
    public struct KeyboardInput
    {
        public short wVK;
        public short wScan;
        public int dwFlags;
        public int time;
        public IntPtr dwExtraInfo;
    };
    [StructLayout(LayoutKind.Sequential)]
    public struct MouseInput
    {
        public int dx;
        public int dy;
        public uint mouseData;
        public uint dwFlags;
        public uint time;
        public IntPtr dwExtraInfo;
    };

    [StructLayout(LayoutKind.Explicit)]
    public struct Input
    {
        [FieldOffset(0)]
        public int type;
        [FieldOffset(8)]
        public MouseInput mi;
        [FieldOffset(8)]
        public KeyboardInput ki;
        [FieldOffset(8)]
        public HardwareInput hi;
    };

    [DllImport("USER32.DLL", SetLastError = true)]
    public static extern int SendInput(short cInputs, Input[] inputs, int cbSize); //inputs amount, inputs array, inputs in byte size. Marshal.SizeOf(typeof(Inputs))

    [DllImport("user32.dll", CharSet = CharSet.Unicode)]
    static extern short VkKeyScanExA(char ch, IntPtr dwhkl);

    [DllImport("user32.dll")]
    static extern short MapVirtualKeyExA(int uCode, int uMapType, IntPtr dwhkl);

    [DllImport("user32.dll")]
    static extern IntPtr GetMessageExtraInfo();
    [DllImport("user32.dll")]
    static extern IntPtr GetKeyboardLayout(ushort idThread);

    const int INPUTMOUSE = 0;
    const int INPUT_KEYBOARD = 1;

    const int KEYEVENTF_EXTENDEDKEY = 0x0001;
    const int KEYEVENTF_KEYUP = 0x0002;
    const int KEYEVENTF_UNICODE = 0X0004;
    const int KEYEVENTF_SCANCODE = 0x0008;

    const int MAPVK_VK_TO_VSC = 0;
    public void sendTheMessage()
    {
        Input[] sInputs;
        sInputs = new Input[1];
        Thread.Sleep(4000);

        Console.WriteLine(VkKeyScanExA('w', GetKeyboardLayout(0)));
        sInputs[0].type = INPUT_KEYBOARD;
        sInputs[0].ki.wVK = 0;
        sInputs[0].ki.wScan = MapVirtualKeyExA(VkKeyScanExA('w', GetKeyboardLayout(0)), MAPVK_VK_TO_VSC, GetKeyboardLayout(0));
        sInputs[0].ki.dwExtraInfo = GetMessageExtraInfo();
        sInputs[0].ki.dwFlags = KEYEVENTF_SCANCODE;

        int cuj = SendInput((short)sInputs.Length, sInputs, Marshal.SizeOf(new Input())); // vai retornar a quantidade de vezes que o input foi enviado com sucesso, se for igual ao tamanho do sInputs ent√£o todos os inputs funcionaram.
        Console.WriteLine(cuj);

        Thread.Sleep(1000);

        sInputs[0].type = INPUT_KEYBOARD;
        sInputs[0].ki.wVK = 0;
        sInputs[0].ki.wScan = MapVirtualKeyExA(VkKeyScanExA('w', GetKeyboardLayout(0)), MAPVK_VK_TO_VSC, GetKeyboardLayout(0));
        sInputs[0].ki.dwExtraInfo = GetMessageExtraInfo();
        sInputs[0].ki.dwFlags = KEYEVENTF_SCANCODE | KEYEVENTF_KEYUP;

        cuj = SendInput((short)sInputs.Length, sInputs, Marshal.SizeOf(new Input()));
    }
}
